#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "common.rkt")
(require "random-extra.rkt")
(require "proc.rkt")
(require "types.rkt")

; **** Printers ****

(define printf-fail 
 (make-printfs (make-color 'red)))

(define printf-succ
 (make-printfs (make-color 'green)))

; **** Datatypes ****

; **** Generators ****

; Evaluates to a valid printf conversion-specifier for the supplied type.
(define (generate-conversion-specifier type [char-prob 0.5])
 (cond
  ([type-pointer? type] (weighted-choice *unsigned-decimal*))
  ; String type
  ([type-inclass? type *string-types*] 's)
  ; Make an actual char specifier if this is a char type and we're lucky
  ([and (eq? 'char (type-size type))
        (< (random) char-prob)] 'c)
  ; Non-pointer decimal number
  ([type-inclass? type *integer-types*]
   ((type->length-spec type) 
    (weighted-choice 
     (if (type-signed? type) *signed-decimal* *unsigned-decimal*)
    )
   )
  )
  ; Non-pointer floating-point number
  ([type-inclass? type *float-types*]
   (string-append 
    (if (eq? 'long-double (type-size type)) "L" "")
    (weighted-choice *floating-point*)
   )
  )
 )
)

(define (generate-integer type)
 (random-bounded-integer 
  (type-bit-depth type) 
  (type-signed? type)
 )
)

(define (generate-pointer)
 (random-bounded-integer *pointer-bit-depth* #f)
)

; Generate a new var structure using the given type structure
(define (generate-var type)
 (cond
  ([type-pointer? type]
   (var type (generate-pointer) pointer-writer)
  )
  ([type-inclass? type *integer-types*]
   (var type (generate-integer type) integer-writer)
  )
  ([type-inclass? type *float-types*]
   (var type (generate-float type) float-writer) 
  )
  ([type-inclass? type *string-types*]
   (var type (generate-string (random-int-between 1 500)) string-writer)
  )
 )
)

(define (generate-vars count)
 (if (= count 0) '()
  (cons
   (generate-var (generate-type))
   (generate-vars (sub1 count))
  )
 )
)

; Generate a string printf statement with 'spec-count' vars printed.
(define (generate-printf spec-count)
 (let ([vars (generate-vars spec-count)]
       [var-string-value (lambda (v) ((var-writer v) v))]
       [var-conversion-spec (lambda (v)
                                  (string-append "%" 
                                   (generate-conversion-specifier
                                    (var-type v))))])
  (string-append
   "snprintf(buffer, BUFFER_LEN, \"" 
   (string-append*
    (map var-conversion-spec vars))
   "\\n\", "   ; Make sure that all format strings end with '\n' for easier
               ; debugging.
   (string-join (map var-string-value vars) ", ")
   "); fputs(buffer, stdout);"
  )
 )
)


(define *printf-prelude* (string->bytes/utf-8
 "#include <stdio.h>
  #include <math.h>
  
  #ifdef MUSL
  #include \"../musl-printf-standalone/musl.h\"
  #define snprintf musl_snprintf
  #endif

  #define BUFFER_LEN 10000
  char buffer[BUFFER_LEN] = { 0 };

  int main() {\n")
)

(define *printf-epilogue*
 #"    return 0;\n}")

(struct printf-stream
 (printf-count print-prelude?)
 #:methods gen:stream
 [(define (stream-empty? stream)
   (<= (printf-stream-printf-count stream) 0))
  (define (stream-first stream)
   (bytes-append
    (if (printf-stream-print-prelude? stream) *printf-prelude* #"")
    #"    " ; Formatting counts
    (string->bytes/utf-8 (generate-printf (random-int-between 1 5)))
    #"\n"
    (if (= (printf-stream-printf-count stream) 1) *printf-epilogue* #"")
   )
  )
  (define (stream-rest stream)
   (printf-stream
    (sub1 (printf-stream-printf-count stream)) #f)
  )]
)


; Returns an iterator that can be supplied to build for the given 
; proc's stdout.
(define (in-stdout proc)
 (list (hash-ref proc 'stdout))
)

(define (compile source binary #:compiler [cc "cc"] . flags)
 (let* ([source (if (pair? source) (string-join source " ") source)]
        [cflags (append flags (list "-o" binary source))]
        [proc (apply run (cons cc cflags))])
  ; When the compiler exits with a non-zero exit code, return #f.
  ; Returns #t otherwise.
  (eq? (hash-ref proc 'status) 0)
 )
)

(define (fuzz trial-count [iter-count 0])
 (build "test.c" (printf-stream trial-count #t))
 (when (ormap (lambda (x) (not (= x 0))) (list
        (system/exit-code "make test-musl") 
        (system/exit-code "make test-local")))
  (printf-fail "Failed to compile a test script.\n")
  (exit 1))
 (build "musl.out" (in-stdout (run "./test-musl")))
 (build "local.out" (in-stdout (run "./test-local")))

 (if (not (eq? (system/exit-code "diff musl.out local.out") 0))
  (begin
   (printf-fail "[~a] Had differing output.\n" iter-count)
   (copy-file "test.c" (format "~a-test.c" iter-count))
   (copy-file "musl.out" (format "~a-musl.out" iter-count))
   (copy-file "local.out" (format "~a-local.out" iter-count))
  )
  (printf-succ "[~a] OK.\n" iter-count)
 )
 (fuzz trial-count (add1 iter-count)))

(fuzz 1000)

; vim: set syn=scheme:
