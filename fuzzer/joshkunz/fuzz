#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "common.rkt")
(require "random-extra.rkt")
(require "proc.rkt")
(require "types.rkt")

; **** Printers ****

(define printf-fail 
 (make-printfs (make-color 'red)))

(define printf-succ
 (make-printfs (make-color 'green)))

; **** Generators ****

; Generate a string printf statement with 'spec-count' vars printed.
(define (generate-printf spec-count)
 (let ([vars (generate-vars spec-count)]
       [var-string-value (lambda (v) ((var-writer v) v))]
       [var-conversion-spec (lambda (v)
                                  (string-append "%" 
                                   (generate-conversion-specifier
                                    (var-type v))))])
  (string-append
   "snprintf(buffer, BUFFER_LEN, \"" 
   (string-append*
    (map var-conversion-spec vars))
   "\\n\", "   ; Make sure that all format strings end with '\n' for easier
               ; debugging.
   (string-join (map var-string-value vars) ", ")
   "); fputs(buffer, stdout);"
  )
 )
)


(define *printf-prelude* (string->bytes/utf-8
 "#include <stdio.h>
  #include <math.h>
  
  #ifdef MUSL
  #include \"../musl-printf-standalone/musl.h\"
  #define snprintf musl_snprintf
  #endif

  #define BUFFER_LEN 10000
  char buffer[BUFFER_LEN] = { 0 };

  int main() {\n")
)

(define *printf-epilogue*
 #"    return 0;\n}")

(struct printf-stream
 (printf-count print-prelude?)
 #:methods gen:stream
 [(define (stream-empty? stream)
   (<= (printf-stream-printf-count stream) 0))
  (define (stream-first stream)
   (bytes-append
    (if (printf-stream-print-prelude? stream) *printf-prelude* #"")
    #"    " ; Formatting counts
    (string->bytes/utf-8 (generate-printf (random-int-between 1 5)))
    #"\n"
    (if (= (printf-stream-printf-count stream) 1) *printf-epilogue* #"")
   )
  )
  (define (stream-rest stream)
   (printf-stream
    (sub1 (printf-stream-printf-count stream)) #f)
  )]
)


; Returns an iterator that can be supplied to build for the given 
; proc's stdout.
(define (in-stdout proc)
 (list (hash-ref proc 'stdout))
)

(define (fuzz trial-count [iter-count 0])
 (build "test.c" (printf-stream trial-count #t))
 (when (ormap (lambda (x) (not (= x 0))) (list
        (system/exit-code "make test-musl") 
        (system/exit-code "make test-local")))
  (printf-fail "Failed to compile a test script.\n")
  (exit 1))
 (build "musl.out" (in-stdout (run "./test-musl")))
 (build "local.out" (in-stdout (run "./test-local")))

 (if (not (eq? (system/exit-code "diff musl.out local.out") 0))
  (begin
   (printf-fail "[~a] Had differing output.\n" iter-count)
   (copy-file "test.c" (format "~a-test.c" iter-count))
   (copy-file "musl.out" (format "~a-musl.out" iter-count))
   (copy-file "local.out" (format "~a-local.out" iter-count))
  )
  (printf-succ "[~a] OK.\n" iter-count)
 )
 (fuzz trial-count (add1 iter-count)))

(sequence-for-each display (printf-stream 10 #t))

;(fuzz 1000)

; vim: set syn=scheme:
