#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "weighted-random.rkt")
(require "defs.rkt")
(require "proc.rkt")

; **** Printers ****

(define printf-fail 
 (make-printfs (make-color 'red)))

(define printf-succ
 (make-printfs (make-color 'green)))

; **** Helpers ****

; Evaluates to #t if value 'v' is in list 'lst'. Evaluates to #f otherwise.
(define (in? v lst)
 (not (false? (member v lst)))
)

(define (string-empty? str)
 (string=? "" str)
)

; **** Datatypes ****

(struct type 
 (sign size pointer) #:transparent)

(struct var 
 (type value writer) #:transparent)

(define (type-signed? type)
 (eq? 'signed (type-sign type)))

(define (type-pointer? type)
 (not (null? (type-pointer type))))

(define (type-inclass? type class)
 (in? (type-size type) class))

(define (type-size->string type)
 (string-replace (symbol->string (type-size type)) "-" " "))

(define (type->string type)
 (string-join
  (if (type-signed? type) "" "unsigned")
  (type-size->string type)))

; **** Variable Writers ****

(define (integer-writer var)
 (let ([type (var-type var)])
  (string-append
   (format "~a" (var-value var))
   ; Add a U specifier for unsigned types.
   (if (type-signed? type) "" "U")
   ; If the bit depth is larger than an int, then we need trainling LLs
   ; when we do the constant assignment.
   (if (> (type-bit-depth type) 
          (type-bit-depth (type 'signed "int" null)))
    (string-upcase (type->length-spec type))
    ""
   )
  )
 )
)

(define (pointer-writer var)
 (string-append "0x"
  (number->string (var-value var) 16)
  *pointer-const-tail*
 )
)

(define (float-writer var)
 (let ([value (var-value var)]
       [size (type-size (var-type var))])
  (cond 
   ([nan? value]
    (string-append "(" (type-size->string type) ") "
     (if (or (eqv? +nan.0 value)
             (eqv? +nan.f value)) "NAN" "-NAN")))
   ([infinite? value]
    (string-append "(" (type-size->string type) ") "
     (if (or (eqv? +inf.0 value)
             (eqv? +inf.f value)) "INFINITY" "-INFINITY")))
   (else
    (string-append (format "~a" value)
     (cond
      ; Constant floats need 'f' after them to be interpreted as floats.
      ([eq? 'float size] "f")
      ; Long double constant floats need 'L' after them to be interpreted
      ; as long-doubles.
      ([eq? 'long-double size] "L")
      ; Otherwise, there's no suffix.
      (else "")
     )
    )
   )
  )
 )
)

(define (string-writer var)
 (string-append "\"" (apply string (var-value var)) "\"")
)

; **** Generation Helpers ****

(define (type->length-spec type)
 (cond
  ([eq? 'char   (type-size type)] "hh")
  ([eq? 'short  (type-size type)] "h")
  (else 
   (make-string 
    (length (regexp-match* #rx"long" (type-size->string type))) #\l)
  )
 )
)

(define (type-bit-depth type)
 (cadr (assoc (type-size type) *numeric-bit-depths*))
)

; **** Generators ****

(define (generate-type [pointer-prob 0.1] [pointer-max-depth 3])
 (let ([sign (weighted-choice *type-signs*)]
       [size (weighted-choice *type-sizes*)]
       [pointer (if (< (random) pointer-prob)
                 (random-int-between 1 pointer-max-depth) 0)])
  ; Float types can't be unsigned, so make sure we only set the sign-value
  ; for integer types.
  (cond
   ([in? size *float-types*] 
    (type 'signed size pointer))
   ([in? size *string-types*]
    (type 'signed size null))
   (else (type sign size pointer))
  )
 )
)

; Evaluates to a valid printf conversion-specifier for the supplied type.
(define (generate-conversion-specifier type [char-prob 0.5])
 (cond
  ([type-pointer? type] (weighted-choice *unsigned-decimal*))
  ; String type
  ([type-inclass? type *string-types*] 's)
  ; Make an actual char specifier if this is a char type and we're lucky
  ([and (eq? 'char (type-size type))
        (< (random) char-prob)] 'c)
  ; Non-pointer decimal number
  ([type-inclass? type *integer-types*]
   ((type->length-spec type) 
    (weighted-choice 
     (if (type-signed? type) *signed-decimal* *unsigned-decimal*)
    )
   )
  )
  ; Non-pointer floating-point number
  ([type-inclass? type *float-types*]
   (string-append 
    (if (eq? 'long-double (type-size type)) "L" "")
    (weighted-choice *floating-point*)
   )
  )
 )
)

(define (random-bounded-integer bit-depth signed?)
 (if signed?
  ; For signed
  (random-int-between 
   (* -1 (expt 2 (- bit-depth 1))) ; -2^(w -1)
   (- (expt 2 (- bit-depth 1)) 1)  ; 2^(w-1) - 1
  )
  ; For unsigned 
  (random-int-between 0 (- (expt 2 bit-depth) 1)) ; 2^w - 1
 )
)

(define (generate-integer type)
 (random-bounded-integer 
  (type-bit-depth type) 
  (type-signed? type)
 )
)

(define (generate-pointer)
 (random-bounded-integer *pointer-bit-depth* #f)
)

(define (random-bytes byte-count)
 (if (= byte-count 0) #""
  (bytes-append 
   (bytes (random-int-between 0 255)) 
   (random-bytes (sub1 byte-count))
  )
 )
)

(define (generate-string len)
 (if (= len 0) '()
  (cons (vector-ref *valid-characters* 
         (random-int-between 0 (vector-length *valid-characters*)))
   (generate-string (sub1 len))
  )
 )
)

; Generate a random real floating-point number.
(define (generate-float type)
 (let ([bytes (/ (type-bit-depth type) 8)])
  (floating-point-bytes->real
   (if (< bytes 8) (random-bytes 4) (random-bytes 8))
  )
 )
)

; Generate a new var structure using the given type structure
(define (generate-var type)
 (cond
  ([type-pointer? type]
   (var type (generate-pointer) pointer-writer)
  )
  ([type-inclass? type *integer-types*]
   (var type (generate-integer type) integer-writer)
  )
  ([type-inclass? type *float-types*]
   (var type (generate-float type) float-writer) 
  )
  ([type-inclass? type *string-types*]
   (var type (generate-string (random-int-between 1 500)) string-writer)
  )
 )
)

(define (generate-vars count)
 (if (= count 0) '()
  (cons
   (generate-var (generate-type))
   (generate-vars (sub1 count))
  )
 )
)

; Generate a string printf statement with 'spec-count' vars printed.
(define (generate-printf spec-count)
 (let ([vars (generate-vars spec-count)]
       [var-string-value (lambda (v) ((var-writer v) v))]
       [var-conversion-spec (lambda (v)
                                  (string-append "%" 
                                   (generate-conversion-specifier
                                    (var-type v))))])
  (string-append
   "snprintf(buffer, BUFFER_LEN, \"" 
   (string-append*
    (map var-conversion-spec vars))
   "\\n\", "   ; Make sure that all format strings end with '\n' for easier
               ; debugging.
   (string-join (map var-string-value vars) ", ")
   "); fputs(buffer, stdout);"
  )
 )
)


(define *printf-prelude* (string->bytes/utf-8
 "#include <stdio.h>
  #include <math.h>
  
  #ifdef MUSL
  #include \"../musl-printf-standalone/musl.h\"
  #define snprintf musl_snprintf
  #endif

  #define BUFFER_LEN 10000
  char buffer[BUFFER_LEN] = { 0 };

  int main() {\n")
)

(define *printf-epilogue*
 #"    return 0;\n}")

(struct printf-stream
 (printf-count print-prelude?)
 #:methods gen:stream
 [(define (stream-empty? stream)
   (<= (printf-stream-printf-count stream) 0))
  (define (stream-first stream)
   (bytes-append
    (if (printf-stream-print-prelude? stream) *printf-prelude* #"")
    #"    " ; Formatting counts
    (string->bytes/utf-8 (generate-printf (random-int-between 1 5)))
    #"\n"
    (if (= (printf-stream-printf-count stream) 1) *printf-epilogue* #"")
   )
  )
  (define (stream-rest stream)
   (printf-stream
    (sub1 (printf-stream-printf-count stream)) #f)
  )]
)


; Returns an iterator that can be supplied to build for the given 
; proc's stdout.
(define (in-stdout proc)
 (list (hash-ref proc 'stdout))
)

(define (compile source binary #:compiler [cc "cc"] . flags)
 (let* ([source (if (pair? source) (string-join source " ") source)]
        [cflags (append flags (list "-o" binary source))]
        [proc (apply run (cons cc cflags))])
  ; When the compiler exits with a non-zero exit code, return #f.
  ; Returns #t otherwise.
  (eq? (hash-ref proc 'status) 0)
 )
)

(define (fuzz trial-count [iter-count 0])
 (build "test.c" (printf-stream trial-count #t))
 (when (ormap (lambda (x) (not (= x 0))) (list
        (system/exit-code "make test-musl") 
        (system/exit-code "make test-local")))
  (printf-fail "Failed to compile a test script.\n")
  (exit 1))
 (build "musl.out" (in-stdout (run "./test-musl")))
 (build "local.out" (in-stdout (run "./test-local")))

 (if (not (eq? (system/exit-code "diff musl.out local.out") 0))
  (begin
   (printf-fail "[~a] Had differing output.\n" iter-count)
   (copy-file "test.c" (format "~a-test.c" iter-count))
   (copy-file "musl.out" (format "~a-musl.out" iter-count))
   (copy-file "local.out" (format "~a-local.out" iter-count))
  )
  (printf-succ "[~a] OK.\n" iter-count)
 )
 (fuzz trial-count (add1 iter-count)))

(fuzz 1000)

; vim: set syn=scheme:
