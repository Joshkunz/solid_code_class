#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "framework.rkt")
(require "weighted-random.rkt")

; **** Helpers ****

; Evaluates to #t if value 'v' is in list 'lst'. Evaluates to #f otherwise.
(define (in? v lst)
 (not (false? (member v lst)))
)

; **** Definitions ****

; Non-Standard specifiers (as far as I can tell) : a A I

(define *signed-decimal*
 (uniformly-weighted '("d" "i")))
(define *unsigned-decimal*  
 (uniformly-weighted '("o" "u" "x" "X")))
(define *floating-point* 
 (uniformly-weighted '("e" "E" "f" "g" "G")))
(define *character* 
 (uniformly-weighted '("c")))
(define *c-string*
 (uniformly-weighted '("s")))
(define *pointer* 
 (uniformly-weighted (cons "p" (map cadr *unsigned-decimal*)))
)

(define *integer-types* '("char" "short" "int" "long int" "long long int"))
(define *float-types*   '("float" "double" "long double"))
(define *string-types*  '("char *"))

(define *datatype-sign*
 (uniformly-weighted '(
  "unsigned"
  "" ; signed
 ))
)

(define *datatype-size*
 (uniformly-weighted 
  (append *integer-types* *float-types* *string-types*))
)

; **** Generators ****

(define (datatype-size datatype) (cadr datatype))
(define (datatype-signed? datatype) 
 (string=? "" (car datatype)))
(define (datatype-pointer? datatype) 
 (not (string=? (caddr datatype) "")))

(define (generate-datatype [pointer-prob 0.1] [pointer-max-depth 3])
 (let ([sign (weighted-choice *datatype-sign*)]
       [size (weighted-choice *datatype-size*)]
       [pointer (if (< (random) pointer-prob)
                 (make-string (random-int-between 1 pointer-max-depth) #\*) "")])
  ; Float types can't be unsigned, so make sure we only set the sign-value
  ; for integer types.
  (cond
   ([in? size *float-types*] 
    (list "" size pointer))
   ([in? size *string-types*]
    (list "" size ""))
   (else (list sign size pointer))
  )
 )
)

(define (integer-length datatype)
 (cond
  ([string=? "char" (datatype-size datatype)] "hh")
  ([string=? "short" (datatype-size datatype)] "h")
  (else 
   (make-string 
    (length (regexp-match* #rx"long" (datatype-size datatype))) #\l)
  )
 )
)

; Evaluates to a valid printf conversion-specifier for the supplied datatype.
(define (conversion-specifier datatype [char-prob 0.5])
 (cond
  ([datatype-pointer? datatype] (weighted-choice *unsigned-decimal*))
  ; String type
  ([in? (datatype-size datatype) *string-types*] "s")
  ; Make an actual char specifier if this is a char type and we're lucky
  ([and (string=? "char" (datatype-size datatype))
        (< (random) char-prob)] "c")
  ; Non-pointer decimal number
  ([in? (datatype-size datatype) *integer-types*]
   (string-append (integer-length datatype) 
    (weighted-choice 
     (if (datatype-signed? datatype) *signed-decimal* *unsigned-decimal*)
    )
   )
  )
  ; Non-pointer floating-point number
  ([in? (datatype-size datatype) *float-types*]
   (string-append 
    (if (regexp-match? #rx"long" (datatype-size datatype)) "L" "")
    (weighted-choice *floating-point*)
   )
  )
 )
)

(define (gt x)
 (let ([d (generate-datatype)])
  (printf "~a: ~a\n" (conversion-specifier d) (string-join d " "))
 )
 (unless (= x 0) (gt (sub1 x)))
)

(gt 100)

;(define (generate-spec type)
; (string-append "%"
;  (generate-flags)
;  (generate-width)
;  (generate-precision)
;  (generate-length)
;  (conversion-spec)
; )
;)

; vim: set syn=scheme:
