#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "framework.rkt")
(require "weighted-random.rkt")

; **** Helpers ****

; Evaluates to #t if value 'v' is in list 'lst'. Evaluates to #f otherwise.
(define (in? v lst)
 (not (false? (member v lst)))
)

(define (string-empty? str)
 (string=? "" str)
)

; **** Definitions ****

(define *pointer-bit-depth* 32)
(define *pointer-const-tail* "")

; 32-bit numeric-type bit-depths
(define *numeric-bit-depths* '(
 ("char" 8)
 ("short" 16)
 ("int" 32)
 ("long int" 32)
 ("long long int" 64)
 ("float" 32)
 ("double" 64)
 ("long double" 96)
))

; Non-Standard specifiers (as far as I can tell) : a A I

(define *signed-decimal*
 (uniformly-weighted '("d" "i")))
(define *unsigned-decimal*  
 (uniformly-weighted '("o" "u" "x" "X")))
(define *floating-point* 
 (uniformly-weighted '("e" "E" "f" "g" "G")))
(define *character* 
 (uniformly-weighted '("c")))
(define *c-string*
 (uniformly-weighted '("s")))
(define *pointer* 
 (uniformly-weighted (cons "p" (map cadr *unsigned-decimal*)))
)

(define *integer-types* '("char" "short" "int" "long int" "long long int"))
(define *float-types*   '("float" "double" "long double"))
(define *string-types*  '("char *"))

(define *datatype-signs*
 (uniformly-weighted '(
  "unsigned"
  "" ; signed
 ))
)

(define *datatype-sizes*
 (uniformly-weighted 
  (append *integer-types* *float-types* *string-types*))
)

; **** Datatypes ****

(struct datatype 
 (sign size pointer) #:transparent)

(struct variable
 (datatype value value-writer) #:transparent)

(define (datatype-signed? datatype)
 (string-empty? (datatype-sign datatype))
)

(define (datatype-pointer? datatype)
 (not (string-empty? (datatype-pointer datatype)))
)

(define (datatype-inclass? datatype class)
 (in? (datatype-size datatype) class)
)

(define (datatype-string datatype)
 (string-join
  (filter (negate string-empty?)
   (list (datatype-sign datatype)
         (datatype-size datatype)
         (datatype-pointer datatype)
   )
  )
 )
)

; **** Variable Writers ****
(define (integer-writer variable)
 (let ([type (variable-datatype variable)])
  (string-append
   (format "~a" (variable-value variable))
   ; Add a U specifier for unsigned types.
   (if (datatype-signed? type) "" "U")
   ; If the bit depth is larger than an int, then we need trainling LLs
   ; when we do the constant assignment.
   (if (> (datatype-bit-depth type) 
          (datatype-bit-depth (datatype "" "int" "")))
    (string-upcase (datatype-length-spec type))
    ""
   )
  )
 )
)

(define (pointer-writer variable)
 (string-append "0x"
  (number->string (variable-value variable) 16)
  *pointer-const-tail*
 )
)

(define (float-writer variable)
 (format "~a" (variable-value variable))
)

(define (string-writer variable)
 (string-append "\"" (apply string (variable-value variable)) "\"")
)

; **** Generation Helpers ****

(define (datatype-length-spec datatype)
 (cond
  ([string=? "char" (datatype-size datatype)] "hh")
  ([string=? "short" (datatype-size datatype)] "h")
  (else 
   (make-string 
    (length (regexp-match* #rx"long" (datatype-size datatype))) #\l)
  )
 )
)

(define (datatype-bit-depth datatype)
 (cadr (assoc (datatype-size datatype) *numeric-bit-depths*))
)

; **** Generators ****

(define (generate-datatype [pointer-prob 0.1] [pointer-max-depth 3])
 (let ([sign (weighted-choice *datatype-signs*)]
       [size (weighted-choice *datatype-sizes*)]
       [pointer (if (< (random) pointer-prob)
                 (make-string (random-int-between 1 pointer-max-depth) #\*) "")])
  ; Float types can't be unsigned, so make sure we only set the sign-value
  ; for integer types.
  (cond
   ([in? size *float-types*] 
    (datatype "" size pointer))
   ([in? size *string-types*]
    (datatype "" size ""))
   (else (datatype sign size pointer))
  )
 )
)

; Evaluates to a valid printf conversion-specifier for the supplied datatype.
(define (generate-conversion-specifier datatype [char-prob 0.5])
 (cond
  ([datatype-pointer? datatype] (weighted-choice *unsigned-decimal*))
  ; String type
  ([datatype-inclass? datatype *string-types*] "s")
  ; Make an actual char specifier if this is a char type and we're lucky
  ([and (string=? "char" (datatype-size datatype))
        (< (random) char-prob)] "c")
  ; Non-pointer decimal number
  ([datatype-inclass? datatype *integer-types*]
   (string-append (datatype-length-spec datatype) 
    (weighted-choice 
     (if (datatype-signed? datatype) *signed-decimal* *unsigned-decimal*)
    )
   )
  )
  ; Non-pointer floating-point number
  ([datatype-inclass? datatype *float-types*]
   (string-append 
    (if (regexp-match? #rx"long" (datatype-size datatype)) "L" "")
    (weighted-choice *floating-point*)
   )
  )
 )
)

(define (random-bounded-integer bit-depth signed?)
 (if signed?
  ; For signed
  (random-int-between 
   (* -1 (expt 2 (- bit-depth 1))) ; -2^(w -1)
   (- (expt 2 (- bit-depth 1)) 1)  ; 2^(w-1) - 1
  )
  ; For unsigned 
  (random-int-between 0 (- (expt 2 bit-depth) 1)) ; 2^w - 1
 )
)

(define (generate-integer datatype)
 (random-bounded-integer 
  (datatype-bit-depth datatype) 
  (datatype-signed? datatype)
 )
)

(define (generate-pointer)
 (random-bounded-integer *pointer-bit-depth* #f)
)

(define (random-bytes byte-count)
 (if (= byte-count 0) #""
  (bytes-append 
   (bytes (random-int-between 0 255)) 
   (random-bytes (sub1 byte-count))
  )
 )
)

(define (generate-string len)
 (if (= len 0) '()
  (let* ([v (random-int-between 0 (sub1 127))]
         [rchar (integer->char 
                 ; If the generated number is greater or equal to the value of 
                 ; the quote character then, shift the value up by one. I.e, skip
                 ; the double quote character.
                 (if (>= v (char->integer #\")) (add1 v) v))])
   (cons rchar (generate-string (sub1 len)))
  )
 )
)

; Generate a random real floating-point number.
(define (generate-float datatype)
 (let ([bytes (/ (datatype-bit-depth datatype) 8)])
  (floating-point-bytes->real
   (if (< bytes 8) (random-bytes 4) (random-bytes 8))
  )
 )
)

; Generate a new variable structure using the given datatype structure
(define (generate-variable datatype)
 (cond
  ([datatype-pointer? datatype]
   (variable datatype (generate-pointer) pointer-writer)
  )
  ([datatype-inclass? datatype *integer-types*]
   (variable datatype (generate-integer datatype) integer-writer)
  )
  ([datatype-inclass? datatype *float-types*]
   (variable datatype (generate-float datatype) float-writer) 
  )
  ([datatype-inclass? datatype *string-types*]
   (variable datatype (generate-string (random-int-between 1 500)) string-writer)
  )
 )
)

(define (gt x)
 (let* ([d (generate-datatype)]
        [v (generate-variable d)])
  ;(printf "~a: ~a\n" (generate-conversion-specifier d) (datatype-string d))
  (unless (void? v)
   (printf "~a = ~a;\n" 
    (datatype-string d)
    ((variable-value-writer v) v))
  )
 )
 (unless (= x 0) (gt (sub1 x)))
)

(gt 10000)

;(define (generate-spec type)
; (string-append "%"
;  (generate-flags)
;  (generate-width)
;  (generate-precision)
;  (generate-length)
;  (conversion-spec)
; )
;)

; vim: set syn=scheme:
