#! /usr/bin/env racket
#lang racket

(require "term-colors.rkt")
(require "common.rkt")
(require "proc.rkt")
(require "printf.rkt")

(define break-triggered? #f)

(define (break-sync)
 (when break-triggered? (exit 0)))

; **** Printers ****

(define printf-fail 
 (make-printfs (make-color 'red)))

(define printf-succ
 (make-printfs (make-color 'green)))

; Returns an iterator that can be supplied to build for the given 
; proc's stdout.
(define (in-stdout proc)
 (list (hash-ref proc 'stdout))
)

(define (fuzz trial-count [iter-count 0])
 (build "test.c" (printf-stream trial-count #t))
 (break-sync)
 (when (ormap (lambda (x) (not (= x 0))) (list
        (system/exit-code "make --quiet test-musl") 
        (system/exit-code "make --quiet test-local")))
  (printf-fail "Failed to compile a test script.\n")
  (exit 1))
 (break-sync)
 (build "musl.out" (in-stdout (run "./test-musl")))
 (build "local.out" (in-stdout (run "./test-local")))
 (break-sync)

 (printf "[I: ~a] " iter-count)
 (if (not (eq? (system/exit-code "diff musl.out local.out > /dev/null") 0))
  (begin
   (printf-fail "Output Differs.\n")
   (copy-file "test.c" (format "test-~a.c" iter-count)))
  (printf-succ "OK.\n")
 )
 (break-sync)
 (fuzz trial-count (add1 iter-count)))

; Make sure our subprocesses are put into a seperate process group so
; that break signals aren't sent to our children.
(subprocess-group-enabled #t)

(define (break-handler exn)
 (if (exn:break? exn)
  (begin
   (set! break-triggered? #t)
   (display "\rCleaning up...\n")
   ((exn:break-continuation exn)))
  ; If we're not handling it, let it rise
  exn
 )
) 

;(sequence-for-each display (printf-stream 100 #t))

; Wrap fuzz call in a break exception handler so that we terminate the fuzz
; at a location where coverate data is available
(call-with-exception-handler break-handler (thunk (fuzz 1000)))

; vim: set syn=scheme:
