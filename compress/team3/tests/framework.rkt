#lang racket

(provide test run-binary build-file rm)

(require "term-colors.rkt")

(define format-fail (make-formats
                     (make-color 'red)))

(define format-succ (make-formats
                     (make-color 'green)))

; Run a function without supplying any arguments to that function
(define (apply1 arg)
 (lambda (proc) (proc arg)))

; Run environment setup instructions and collect any cleanup routines
(define (create-test-environment setup succ-cleanup fail-cleanup finally)
 (if (null? setup) (values succ-cleanup fail-cleanup finally)
  ; else
  (let* ([current-setup (car setup)]
         [setup-response (current-setup)]
         [apply-cleanup
          (lambda (flag old-cleanup)
           (let* ([added-pair (assoc flag setup-response)]
                  [added-cleanup (if added-pair (cadr added-pair) '())])
            (if (not (list? added-cleanup))
             (append old-cleanup (list added-cleanup))
             (append old-cleanup added-cleanup)
            )
           )
          )
         ]
         [new-succ-cleanup (apply-cleanup 'on-success succ-cleanup)]
         [new-fail-cleanup (apply-cleanup 'on-failure fail-cleanup)]
         [new-finally (apply-cleanup 'finally finally)])
   (create-test-environment
    (cdr setup) new-succ-cleanup new-fail-cleanup new-finally)
  )
 )
)

; General test result checking code. Evaluates to #t if the test passed,
; and evaluates to #f if the test failed.
(define (evaluate-test test-output test-checks)
 (let* ([check-runner (lambda (check) (check test-output))]
        [check-results (map check-runner test-checks)]
        [checks-passed? (andmap car check-results)])
  (if checks-passed? (values #t (void)) ; else
   (values #f
    (let ([make-lines (lambda (outputs)
                       (string-join
                        (map (lambda (v) (string-append "    " v)) outputs)
                        "\n"))])
    (string-join
      (map (lambda (v) (make-lines (cdr v))) check-results)
      "\n" #:after-last "\n")
    )
   )
  )
 )
)

; Fully execute the given test.
(define (test test-name environ execution checks #:succ [on-succ '()] 
                                                 #:fail [on-fail '()] 
                                                 #:finally [finally '()])
 (let-values ([(succ-cleanup fail-cleanup finally-cleanup)
               (create-test-environment environ on-succ on-fail finally)]
              [(checks-succeded? diagnosis)
               (evaluate-test (execution) checks)])
  (if checks-succeded?
   (begin (printf "~a  ~a\n" (format-succ "OK") test-name)
          (for-each (apply1 test-name) succ-cleanup))
   (begin (printf "~a  ~a\n" (format-fail "FAILED") test-name)
          (display diagnosis)
          (for-each (apply1 test-name) fail-cleanup))
  )
  (for-each (apply1 test-name) finally-cleanup)
  checks-succeded?
 )
)

(define (rm . files) (thunk*
 (letrec ([inner-rm
           (lambda (_files)
            (unless (null? _files)
             (when (file-exists? (car _files))
              (delete-file (car _files)))
             (inner-rm (cdr _files))
            )
           )])
  (inner-rm files)
 )
 )
)

; Copies the given source file to the given destination file.
(define (cp source dest #:exists [exists 'truncate]) (thunk
 (let ([input (open-input-file source #:mode 'binary)]
       [output (open-output-file dest #:mode 'binary #:exists exists)])
  (copy-port input output)
  (close-output-port output)
  (close-input-port input)
 )
 (list)
))


; Returns a function that when executed writes the bytes generated by
; 'test-generator' into 'to-file' and returns functions neccicary to cleanup
; the file.
(define (build-file test-output-sequence to-file) (thunk
 (let* ([output (open-output-file to-file #:exists 'truncate)]
        [writer (lambda (bytes) (write-bytes bytes output))])
  (begin0
   ; Build our cleanup routines
   (list (list 'on-failure
    (lambda (test-name)
     (let ([saved-file-name
            (string-append (string-downcase
             (string-replace (string-normalize-spaces test-name) " " "-"))
             ".input")])
      (rename-file-or-directory to-file saved-file-name #t)
      (printf "Triggering input saved into: ~a\n\n" saved-file-name))))
    (list 'on-success (thunk* (delete-file to-file)))
   )
   ; Generate the file
   (sequence-for-each writer test-output-sequence)
   (close-output-port output)
  )
 )
 )
)

; Returns a function that when executed runs the supplied command with the
; supplied arguments, and returns the commands response code, stdout (as bytes),
; and stderr (as bytes).
(define (run-binary binary . flags)
 (thunk
 ; Run the program as a subprocess
 (let-values ([(proc proc-stdout proc-stdin proc-stderr)
               (apply subprocess (append (list #f #f #f binary) flags))])
  (begin0
   ; Collect the process's output and status code for return
   (let ([proc-output (port->bytes proc-stdout)]
         [proc-error (port->bytes proc-stderr)])
    (subprocess-wait proc)
    (make-immutable-hash `(
     (status ,(subprocess-status proc))
     (stdout ,proc-output)
     (stderr ,proc-error)
     (binary ,binary)
     (args   ,flags)
     )
    )
   )
   ; Cleanup the communication channels.
   (close-output-port proc-stdin)
   (close-input-port proc-stdout)
   (close-input-port proc-stderr)
  )
 )
 )
)
